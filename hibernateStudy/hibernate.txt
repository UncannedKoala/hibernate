* When using the Hibernate Entity manager approach, you can either use the xml(persistance.xml file) to configure the hibernate in your maven application, or use the PersistanceUnitInfo interface(CustomPersistanceUnitInfo.java implements PersistanceUnitInfo).

*PERSISTANCE.XML route
1).	Create a persistence.xml file in the META-INF folder of your project.
2). 	EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new CustomPersistenceUnitInfo(), new HashMap<>());
3). 	EntityManager em = emf.createEntityManager();  												// represents the context
4). ->	em.getTransaction().begin();	...........	em.getTransaction().commit();	em.close();	<-

**PERSISTANCE_UNIT_INFO route
1). create a class for custome persistance unit info	...	public class CustomPersistenceUnitInfo implements PersistenceUnitInfo
2). override the methods and provide the values getPersistanceUnitName(), getPersistenceProviderClassName(), getTransactionType(), getJtaDataSource(), getManagedClassNames(), 
3). ->
    @Override
    public DataSource getJtaDataSource() {
        HikariDataSource dataSource = new HikariDataSource();

        dataSource.setJdbcUrl("jdbc:mysql://localhost/demo");
        dataSource.setUsername("root");
        dataSource.setPassword("");

        return dataSource;
    }
<-
4). ->
	String puName = "pu-name";

        Map<String, String> props = new HashMap<>();
        props.put("hibernate.show_sql", "true");
        props.put("hibernate.hbm2ddl.auto", "create"); // create, none, update

        EntityManagerFactory emf = new HibernatePersistenceProvider()
                .createContainerEntityManagerFactory(new CustomPersistenceUnitInfo(puName), props);

        EntityManager em = emf.createEntityManager();
<-

*	EntityManager em = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new CustomPersistenceUnitInfo("persistanceUnitName"), props).createEntityManager();
	em.persist();		-> Adding an entity in the context
	em.find()		-> Finds by PK. Get from DB and add it to the context if it doesn't already exist
	em.remove();		-> Marking entity for removal
	em.merge();		-> Merges an entity from outside the context to the context.
	em.refresh();		-> Mirror the context from the database(overrides the context entity with DB entity)
	em.detach();		-> Taking the entity out of the context
	em.getReference();	-> Using decorator pattherm, returns a shell(Empty object) of the required type, but the select query is not executed unles the object reference is used. 
				Refer to it as a lazily fetched initiallized object.
	em.flush();		-> Mirror the context entites to the DB NOW!!!, do not wait for the commit().

	em.createQuery("hql query", ResultClass.class);
	i.e. em.createQuery("SELECT p FROM Person p WHERE p.passport.passportNumber = :number", Person.class).setParameter("number", "ASfa46AsDa5").getSingleResult();

* UUID are good for indexing when the database has a type for UUIDs, But has bad performace when used as String. Consider the data is sent to frontend and the security is poorly implemented, user might try playing with pathVariable/queryParam value and access data he is not supposed to access. But the UUID not easy to anticipate and do not follow a pattern.

* We can have 2 ids, 1 UUID to communicate with the frontend(external id) and another to use in app(internal id)

* we can have a 'SIMPLE primary key' or the 'COMPOSED primary key'.

* For hbm2ddl.auto property the list of possible options is:
validate: validate that the schema matches, make no changes to the schema of the database, you probably want this for production.
update: update the schema to reflect the entities being persisted
create: creates the schema necessary for your entities, destroying any previous data.
create-drop: create the schema as in create above, but also drop the schema at the end of the session. This is great in early development or for testing.

* If you are using Hibernate's proprietary API, you'll need the hibernate.cfg.xml. If you are using JPA i.e. Hibernate EntityManager, you will need the persistence.xml.

* Hibernate's proprietary API refers to the traditional way of configuring and using Hibernate, which involves using the hibernate.cfg.xml configuration file. This approach is more flexible and allows for more fine-grained control over the Hibernate settings. However, it requires more manual configuration and can be more error-prone.

* Hibernate EntityManager is a more streamlined approach introduced with the Java Persistence API (JPA), which is a standard API for managing persistence in Java applications. In this approach, the configuration is done using the persistence.xml file, which is located in the META-INF folder of the application. This approach is more straightforward and easier to set up, as it provides a more minimalist configuration file that can be easily generated by tools like the Hibernate Tools Maven Plugin.

* Hibernate's proprietary API:
1). Create a hibernate.cfg.xml file in the root directory of your project.
2). Configure the Hibernate settings in the hibernate.cfg.xml file, such as the database connection, dialect, and other properties.
3). Use the Hibernate API to create a SessionFactory instance, which will be used to create Session objects for interacting with the database.
4). Use the Session objects to perform CRUD (Create, Read, Update, Delete) operations on the database.

*Hibernate EntityManager:
1). Create a persistence.xml file in the META-INF folder of your project.
2). Configure the Hibernate settings in the persistence.xml file, such as the database connection, dialect, and other properties.
3). Use the Hibernate EntityManager API to create an EntityManagerFactory instance, which will be used to create EntityManager objects for interacting with the database.
4). Use the EntityManager objects to perform CRUD operations on the database.

* Hibernate 6 requires Java 11 or higher. This is because Hibernate 6 uses features that are only available in Java 11 and higher, such as the Java Module System and the new HttpClient API.

* Hibernate 6 is included in Spring Boot framework version 3. To migrate to Hibernate 6, you'll need to move to Java 17, the minimum version supported by Spring Boot 3. 

* COMPLEX/ COUMOUND ID =  custom id is a id composed of multiple column values instead of just 1, can set up by following 2 methods:
NOTE :: In both the approaches we need to implement the <Serializable> interface
1). On <Entity> class, we have an instance variable of the <ComplexId> class in the <Entity> class and mark the instance variable with @EmbeddedId, use @Embeddable on the <ComplexId> class.
->
	@Entity
	public class Entity {
		@EmbeddedId
    		private CompoundKey compoundKey;
		....
	}

	@Embeddable
	public class CompoundKey implements Serializable {
		private Long column1;
		private String column2;
		... getters()/setters()/hashCode()/equals()/toString()
	}	
<-
2). On <Entity> class, use @IdClass(value = CustomID.class) on class and put @Id on instance variables involved in the ComplexId
->
@IdClass(CompoundKey.class)
@Entity
public class Entity {
	@Id
	private Long column1;

	@Id
	private String column2;

	... other fields, getters and setters
}

public class CompoundKey implements Serializable {
	private Long column1;
	private String column2;

	... constructors,getters,setters,equals, and hashCode methods
}
<-

* column name of the primary key is "table_id" by default.

* Each instance variable is defined as a column in the table.

* In <Entity> has-A <Entity> we can not use the @Column on that variable, instead use the @JoinColumn.

* @JoinColumn is used on the <Entity> typed reference variable in another <Entity> class which exhibits has-A relation, when you want to change the column name for the foreign key column.
i.e. 	<Person> has-A <Passport> uni-directional relation, In the Person Class{... @OneToOne @JoinColumn(name = "foreignKey_to_passport") private Passport passport; ...}

* In @OneToOne bi-directional relationship 'mappedBy' will always be used on the opposite side of the owner of <Entity>, and the value to that is the name of variable representing the owned <Entity> in the owner <Entity>
i.e. 	<Person> has-A <Passport> bi-directional relation, if we want person table to contain the passport refrence and not create a third table, in Passport class 
	{... @OneToOne(mapppedBy = "PassportRefVarInPerson")private Person person ...}

* @OneToOne has 'cascade' property whcih can have jakarta.persistence.CascadeType.ALL,PERSIST,MERGE,REMOVE,REFRESH,DETACH
i.e. 	@OneToOne(cascade = jakarta.persistence.CascadeType.PERSIST),
	@OneToOne(cascade = {jakarta.persistence.CascadeType.PERSIST, jakarta.persistence.CascadeType.REMOVE, jakarta.persistence.CascadeType.MERGE, jakarta.persistence.CascadeType.REFRESH})

* @Cascade can have the values org.hibernate.annotations.CascadeType.ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH, LOCK
i.e. 	@Cascade({CascadeType.PERSIST, CascadeType.REMOVE}), @Cascade(CascadeType.PERSIST)
NOTE :: CascadeType.ALL should be avoided

* CascadeType is an enum in both jakarta.persistence.CascadeType and org.hibernate.annotations.CascadeType packages.

* 'fetch' of any SVT(simple value type) is always EAGER by default, but incase of CVTs(complex value types) it is lazily fetched which can be changed using fetch property of @OneToOne and @OneToMany or @ManyToMany
i.e. @OneToMany(cascade = {CascadeType.PERSIST, CascadeType.REMOVE}, fetch = FetchType.LAZY)

* 'optional' is a property in @OneToOne only and not it either of @OneToMany, @ManyToMany. this tells if the value can be null or not. meaning that if the owner entity is allowed to have null as owned entity value. Its value is true by default
i.e. @OneToOne(optional = false)

* The 1:1 relationship, @OneToOne annotation(both uni-directionnal and bi-directional) does not create a third table but only creates a column in the owner <Entity> table.

* The 1:n bi-directional relationship, we have to go for @OneToMany or @ManyToOne on either <Entity>. We use the @OneToMany in the <Entity> that has the relation to multiple <Entites>, and then we have @ManyToOne in the <Entity> that has relation only to one <Entity>.

* @OneToMany represents the '1' side of the '1:n' relationship, while @ManyToOne represents 'n' side of the '1:n' relation.

* In '1:n' (uni-directional or bi-directional) relationship, the foreign key column is created on the table representing the 'n' side of the relation because the '1' side of the relationship can not hold multiple values for a single <Entity>.

* Here's how to prevent SQL injection attacks in Java:

1. Use Prepared Statements:
Never concatenate user input directly into SQL queries. This is the most common vulnerability.
Use PreparedStatements to create query templates with placeholders for values.
Set parameters using setString(), setInt(), etc., which automatically escape input.
Example:
->
String username = request.getParameter("username");
String password = request.getParameter("password");

PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users WHERE username = ? AND password = ?");
stmt.setString(1, username);
stmt.setString(2, password);
ResultSet rs = stmt.executeQuery();
<-
And do not use like "conn.createStatement().executeQuery(query);"

2. Validate User Input:
Check data types and lengths to ensure they match expected values.
Use whitelisting to allow only specific characters or patterns.
Sanitize input for special characters or HTML tags.

3. Use Stored Procedures:
Encapsulate SQL logic in stored procedures on the database server.
Call stored procedures with parameters to prevent direct SQL injection.

4. Use Object-Relational Mapping (ORM) Frameworks:
Frameworks like Hibernate or JPA handle query creation and parameterization automatically.
Reduce manual SQL interaction and potential for errors.

5. Limit Database Permissions:
Grant the application account only the necessary permissions to access specific tables or views.
Minimize potential damage in case of a successful attack.

6. Regularly Scan for Vulnerabilities:
Use security tools to scan your application for SQL injection vulnerabilities.
Stay updated on security patches for libraries and frameworks.
Remember:
Be cautious with dynamic SQL features like EXECUTE IMMEDIATE or sp_executesql.
Apply input validation and parameterization consistently to all user-supplied data.
Stay informed about SQL injection techniques and best practices.

* Never give power of DDLs to hibernate, always dependencies such as flyway, Liquibase.