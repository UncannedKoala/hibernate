*When using the Hibernate Entity manager approach, you can either use the xml(persistance.xml file) to configure the hibernate in your maven application, or use the PersistanceUnitInfo interface(CustomPersistanceUnitInfo.java implements PersistanceUnitInfo).

**PERSISTANCE.XML route
1). Create a persistence.xml file in the META-INF folder of your project.
2). 	EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new CustomPersistenceUnitInfo(), new HashMap<>());
3). 	EntityManager em = emf.createEntityManager();  												// represents the context
4). ->	em.getTransaction().begin();	...........	em.getTransaction().commit();	em.close();	<-

**PERSISTANCE_UNIT_INFO route
1). create a class for custome persistance unit info	...	public class CustomPersistenceUnitInfo implements PersistenceUnitInfo
2). override the methods and provide the values getPersistanceUnitName(), getPersistenceProviderClassName(), getTransactionType(), getJtaDataSource(), getManagedClassNames(), 
3). ->
    @Override
    public DataSource getJtaDataSource() {
        HikariDataSource dataSource = new HikariDataSource();

        dataSource.setJdbcUrl("jdbc:mysql://localhost/demo");
        dataSource.setUsername("root");
        dataSource.setPassword("");

        return dataSource;
    }
<-
4). ->
	String puName = "pu-name";

        Map<String, String> props = new HashMap<>();
        props.put("hibernate.show_sql", "true");
        props.put("hibernate.hbm2ddl.auto", "create"); // create, none, update

        EntityManagerFactory emf = new HibernatePersistenceProvider()
                .createContainerEntityManagerFactory(new CustomPersistenceUnitInfo(puName), props);

        EntityManager em = emf.createEntityManager();
<-

*	EntityManager em = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new CustomPersistenceUnitInfo("persistanceUnitName"), props).createEntityManager();
	em.persist();		-> Adding an entity in the context
	em.find()		-> Finds by PK. Get from DB and add it to the context if it doesn't already exist
	em.remove();		-> Marking entity for removal
	em.merge();		-> Merges an entity from outside the context to the context.
	em.refresh();		-> Mirror the context from the database(overrides the context entity with DB entity)
	em.detach();		-> Taking the entity out of the context
	em.getReference()	-> using decorator pattherm, returns a shell(Empty object) of the required type, but the select query is not executed unles the object reference is used. 
				Refer to it as a lazily fetched initiallized object.

* UUID are good for indexing when the database has a type for UUIDs, But has bad performace when used as String. Consider the data is sent to frontend and the security is poorly implemented, user might try playing with pathVariable/queryParam value and access data he is not supposed to access. But the UUID not easy to anticipate and do not follow a pattern.

* We can have 2 ids, 1 UUID to communicate with the frontend(external id) and another to use in app(internal id)

*we can have a 'SIMPLE primary key' or the 'COMPOSED primary key'.

*For hbm2ddl.auto property the list of possible options is:
validate: validate that the schema matches, make no changes to the schema of the database, you probably want this for production.
update: update the schema to reflect the entities being persisted
create: creates the schema necessary for your entities, destroying any previous data.
create-drop: create the schema as in create above, but also drop the schema at the end of the session. This is great in early development or for testing.

*If you are using Hibernate's proprietary API, you'll need the hibernate.cfg.xml. If you are using JPA i.e. Hibernate EntityManager, you will need the persistence.xml.

*Hibernate's proprietary API refers to the traditional way of configuring and using Hibernate, which involves using the hibernate.cfg.xml configuration file. This approach is more flexible and allows for more fine-grained control over the Hibernate settings. However, it requires more manual configuration and can be more error-prone.

*Hibernate EntityManager is a more streamlined approach introduced with the Java Persistence API (JPA), which is a standard API for managing persistence in Java applications. In this approach, the configuration is done using the persistence.xml file, which is located in the META-INF folder of the application. This approach is more straightforward and easier to set up, as it provides a more minimalist configuration file that can be easily generated by tools like the Hibernate Tools Maven Plugin.

*Hibernate's proprietary API:
1). Create a hibernate.cfg.xml file in the root directory of your project.
2). Configure the Hibernate settings in the hibernate.cfg.xml file, such as the database connection, dialect, and other properties.
3). Use the Hibernate API to create a SessionFactory instance, which will be used to create Session objects for interacting with the database.
4). Use the Session objects to perform CRUD (Create, Read, Update, Delete) operations on the database.

*Hibernate EntityManager:
1). Create a persistence.xml file in the META-INF folder of your project.
2). Configure the Hibernate settings in the persistence.xml file, such as the database connection, dialect, and other properties.
3). Use the Hibernate EntityManager API to create an EntityManagerFactory instance, which will be used to create EntityManager objects for interacting with the database.
4). Use the EntityManager objects to perform CRUD operations on the database.

*Hibernate 6 requires Java 11 or higher. This is because Hibernate 6 uses features that are only available in Java 11 and higher, such as the Java Module System and the new HttpClient API.

*Hibernate 6 is included in Spring Boot framework version 3. To migrate to Hibernate 6, you'll need to move to Java 17, the minimum version supported by Spring Boot 3. 

*COMPLEX/ COUMOUND ID =  custom id is a id composed of multiple column values instead of just 1, can set up by following 2 methods:
NOTE :: In both the approaches we need to implement the <Serializable> interface
1). On <Entity> class, we have an instance variable of the <ComplexId> class in the <Entity> class and mark the instance variable with @EmbeddedId, use @Embeddable on the <ComplexId> class.
->
	@Entity
	public class Entity {
		@EmbeddedId
    		private CompoundKey compoundKey;
		....
	}

	@Embeddable
	public class CompoundKey implements Serializable {
		private Long column1;
		private String column2;
		... getters()/setters()/hashCode()/equals()/toString()
	}	
<-
2). On <Entity> class, use @IdClass(value = CustomID.class) on class and put @Id on instance variables involved in the ComplexId
->
@IdClass(CompoundKey.class)
@Entity
public class Entity {
	@Id
	private Long column1;

	@Id
	private String column2;

	... other fields, getters and setters
}

public class CompoundKey implements Serializable {
	private Long column1;
	private String column2;

	... constructors,getters,setters,equals, and hashCode methods
}
<-